# ***Spring MVC и изграждане на REST APIs***

## Въведение
В третото занятие се запознахме с основните концепции на Spring MVC (Model-View-Controller)
и RESTful уеб услуги, които са основни компоненти за изграждането на уеб приложения и
API с използване на Spring Boot. Разгледахме как Spring MVC осигурява структуриран 
подход за създаване на уеб приложения чрез разделяне на логиката на приложение в три 
основни компонента – модел, изглед и контролер.

Основните теми в това занятие включват:
- Разработване на уеб приложения с Spring MVC, включително използване на анотации като `@Controller`,
  `@RequestMapping`, `@GetMapping`, `@PostMapping` и др. за управление на HTTP заявки.
- Създаване и конфигуриране на RESTful уеб услуги с Spring Web, с използване на анотации
като `@RestController`, `@RequestMapping` и работа с HTTP методи (GET, POST, PUT, DELETE).
- Управление на входни и изходни данни с помощта на анотации като `@RequestParam`,
  `@PathVariable`, `@RequestBody` и `@ResponseBody`.

В този документ се обобщават основните аспекти на Spring MVC и REST, включително:
- Какво е Model-View-Controller ?
- Разработване на контролери за обработка на HTTP заявки
- Начини за валидиране на HTTP request body
- Работа с view технологии - Thymeleaf и използване на Model & ModelAndView
- Създаване на и обработка на RESTful API с Spring
- Работа с JSON за обмен на данни

## Съдържание
- [Какво е MVC ?](#mvc)
- [MVC Компоненти](#mvc-components)
- [Как да създадем контролер в Spring](#controller-creation-spring)
- [Основни типове и анотации](#handler-method-type-annotaions)
- [Валидация на HTTP Request Body](#validation-request-body)
- [Thymeleaf](#thymeleaf)
- [REST APIs](#rest-apis)
- [Допълнителни материали](#resources)

<a id="mvc"></a>
## I. Какво е MVC (Model-View-Controller) ?

**MVC** е архитектурна идея (*design pattern*), която се използва за изграждане на приложения с 
потребителски интерфейс. Тя разделя приложението на три взаимносвързани компонента, 
като така се улеснява неговото развитие, поддръжка и разширяване.

### 1. История и еволюция
- Концепцията за MVC възниква още през **1970 г.**, първоначално създадена за **десктоп апликации с графичен интерфейс**.
- С времето се адаптира за изграждане на **уеб приложения**, които работят в среда, свързана с Интернет.
- Днес MVC е широко разпространен и използван в много популярни рамки (frameworks), 
сред които и **Spring MVC** – една от основните технологии в света на Java уеб разработката.

### 2. Предимства на MVC
Тъй като MVC разделя основните компоненти на приложението, това позволява на разработчиците 
да работят **паралелно по различни части**, без да си пречат или да се налага да разбират 
пълната структура на другата част.

>Например:
>- Един екип може да поеме изграждането на **back-end логиката** – 
>проектиране на структурата на данните и дефиниране как потребителят
>взаимодейства с тях, без нуждата от завършен потребителски интерфейс.
>- Друг екип може да се фокусира върху **front-end частта** – създаване 
>и тестване на изгледа на приложението, дори когато все още няма реални данни.

<a id="mvc-components"></a>
## II. MVC Компоненти

MVC разделя приложението на три основни компонента, които работят заедно,
но са ясно разграничени по отговорности:

### 3.1 Основни:

#### Controller

- Посредник между **потребителския интерфейс (View)** и **модела (Model)**.
- Обработва вход от потребителя (напр. заявка от браузъра), избира подходяща логика, и връща резултат към изгледа.
- Иска/извиква **определен Модел**, когато трябва да обработи или извлече данни;
- **Променя данните в модела**, когато това се налага (например при съхраняване на нов запис);
- **Зарежда определен изглед (View)**, за да покаже резултатите на потребителя.

> #### ⚠️ Thin Controller vs. Fat Model
> В добрата практика на MVC се препоръчва:
> - Контролерът да бъде **"тънък" (thin controller)** – той само препраща заявката, избира подходящ модел/изглед и не съдържа сложна логика;
> - Цялата бизнес логика да се намира в **"дебел модел" (fat model)** – моделът трябва да знае как да обработи и трансформира данните.
---

#### Model

- Представлява **структурата и логиката на данните** в приложението.
- Отговаря за съхранението, достъпа и обработката на данните.
- Не съдържа информация за визуализацията или начина, по който се показва на потребителя.
> Примери:
>- Java класове (POJO), които описват обекти (напр. `User`, `Product`).
>- ORM решения като JPA или Hibernate, които работят с база данни. 
>- Логика за валидиране, изчисления или свързани бизнес правила.
---

#### View

- Отговаря за **визуализацията на данните** и **интерфейса**, с който потребителят взаимодейства.
- Представя информацията, предоставена от контролера, по ясен и разбираем начин.
- Не съдържа бизнес логика или достъп до данни.
>Примери:
>- HTML страници с Thymeleaf.
>- JSP файлове.
>- Front-end технологии като React или Angular, когато се използват с бекенд.
---

### Взаимодействие между компонентите:

1. **Потребителят** извършва действие (напр. кликва бутон или подава форма).
2. **Контролерът** приема заявката, обработва я, евентуално извиква методи от модела.
3. **Моделът** връща нужната информация или състояние.
4. **Контролерът** предава тази информация на изгледа.
5. **Изгледът** показва информацията на потребителя.

---
### 3.2 Допълнителни:

#### Front Controller (или Рутер)
**Front Controller** е централен компонент във всяко MVC-базирано уеб приложение, който:

- **приема всички входящи HTTP заявки** (независимо от пътя);
- **централизира управлението** на заявките и ги насочва към съответния контролер;
- изпълнява предварителни действия като:
    - проверка за сесия;
    - удостоверяване на потребител;
    - логване;
    - маршрутизиране на заявките;
    - обработка на грешки;
- след това предава заявката към специфичния контролер, който поема логиката за съответното действие.

>⚠️ **Front Controller в Spring MVC**
>- В Spring MVC тази роля се изпълнява от класа `DispatcherServlet`, който:
>- служи като **централен входен пункт** за всички HTTP заявки;
>- автоматично разпределя заявките към правилните контролери чрез конфигурираните маршрути;
>- използва конфигурация, за да реши кой `@Controller` и кой `@RequestMapping` отговаря на дадена заявка;
>- обработва модела и избира изгледа, който ще бъде визуализиран накрая (например с Thymeleaf или JSP).

#### Handler Mapping

В контекста на **Front Controller** (в Spring – `DispatcherServlet`), **Handler Mapping** е механизъм, 
който отговаря за **намиране на правилния контролер** (handler), който трябва да обработи дадена HTTP заявка.

#### Как работи:

1. Потребителят изпраща HTTP заявка към приложението (напр. `/hangman-games`).
2. `DispatcherServlet` (Front Controller) **приема заявката**.
3. `DispatcherServlet` използва **Handler Mapping**, за да определи **кой контролер и кой метод** трябва да я обработи.
4. След това предава заявката на този контролер.
5. Контролерът обработва заявката, извиква нужния модел и връща изгледа (View).

#### Как се извършва съпоставянето?

Handler Mapping може да се базира на:

- **анотации** (най-често в Spring):
    - `@RequestMapping`, `@GetMapping`, `@PostMapping` и др.;
- **имена на методи или класове** (в някои други MVC имплементации);
- **XML конфигурация** (по-стар стил);
- **път и HTTP метод на заявката** (URL + GET/POST/...).

<a id="controller-creation-spring"></a>
## III. Как да създадем контролер в Spring

В **Spring MVC** контролирането на HTTP заявките се извършва чрез **анотираните контролери**. 
Това е начинът, по който един Java клас става **Spring Bean**, способен да обработва HTTP заявки
и да комуникира с моделите и изгледите.

### 1. Как един Java клас става контролер:

#### Използвайки **`@Controller`** анотацията

- Когато използваме анотацията `@Controller` върху клас, той става **Spring Bean** и може да обработва HTTP заявки.
- Spring автоматично ще регистрира този клас като контролер и ще се грижи за инжектирането на зависимостите в него.
- Когато потребителят изпрати заявка към приложение, Spring проверява съвпадението между URL пътя и анотираните методи в контролера
- Това е клас, използван най-често в уеб приложения, които връщат HTML страници.


#### Използвайки **`@RestController`** анотацията 

**`@RestController`** е специализация на **`@Controller`** в Spring, 
която автоматично добавя **`@ResponseBody`** към всички методи в контролера. 
Това означава, че резултатите от методите ще бъдат връщани като отговори в HTTP заявката,
вместо да бъдат пренасочвани към изгледи (HTML).

- Когато използваме **`@RestController`** върху клас, Spring автоматично обработва всички методи в този клас, 
така че те да връщат JSON (или друг формат) като отговор.
- `@RestController` се използва основно при изграждане на **RESTful уеб услуги**, 
където целта е да предоставяме данни, а не HTML изгледи.

---
#### Един КОНТРОЛЕР
>⚠️ ТРЯБВА ДА:
>- Да приеме HTTP заявка;
>- Да валидира входните данни (ако е нужно);
>- Да извика подходяща услуга (сервиз/сървис клас);
>- Да върне резултата като HTTP отговор.
>- Четимост – лесно се разбира какво прави контролерът.
>- Повторна употреба – логиката в service слоя може да се използва и от други места.

>⚠️ НЕ ТРЯБВА ДА:
> - сложни проверки и бизнес логика
> - директни заявки към базата данни
> - изчисления, преобразувания и т.н.

### 2. Създаване на URL Mapping с методите на контролера в Spring MVC

**URL Mapping** в Spring MVC е процесът на свързване на HTTP заявки с методи от контролера.
Това се постига чрез използването на анотации като `@RequestMapping`, `@GetMapping`, 
`@PostMapping`, `@PutMapping`, `@DeleteMapping` и други. Чрез тези анотации можем да указваме
към кои методи да се насочват различни HTTP заявки, като по този начин създаваме правилното
мапиране на пътищата и операциите в приложението.

#### 2.1 Чрез `@RequestMapping`

Анотацията **`@RequestMapping`** е основната анотация за мапиране на HTTP заявки към методи на контролера.
Тя позволява да зададем URL път, HTTP метод, параметри, заглавки и формати на входящите/изходящите данни.

>Примери:
>- @RequestMapping("/hangman-games") задава основния път за всички методи в контролера.
>- @RequestMapping(method = RequestMethod.GET) обработва GET заявки към /hangman-games.
>- @RequestMapping(method = RequestMethod.POST) обработва POST заявки към същия URL.

---
#### 2.2 Чрез `@GetMapping`

**`@GetMapping`** е специализирана анотация в Spring MVC, която се използва за обработка на **GET заявки** 
към конкретен URL път. Това е кратката версия на анотацията `@RequestMapping(method = RequestMethod.GET)`. 
Тя е по-препоръчителна за използване, когато трябва да обработваме заявки от тип GET, тъй като е по-ясна и директна.

- GET заявките се използват за извличане на информация от сървъра без да се променят ресурсите. 
Пример за такъв случай е извличането на данни от база данни, показване на списък с елементи
или зареждане на определен ресурс.

#### 2.3 Чрез `@PostMapping`

**`@PostMapping`** е специализирана анотация в Spring MVC, която се използва за обработка на **POST заявки**
към конкретен URL път. Тя е кратката версия на анотацията `@RequestMapping(method = RequestMethod.POST)`
и е предназначена за обработка на заявки, които изпращат данни към сървъра, например за създаване
на нови ресурси или обработка на форма.

- POST заявките се използват, когато клиентът трябва да изпрати данни към сървъра, като например
при създаване на нови записи в база данни или при изпращане на данни от потребителски интерфейс.

#### 2.4 Чрез `@PutMapping`

**`@PutMapping`** е специализирана анотация в Spring MVC, която се използва за обработка на 

**PUT заявки** към конкретен URL път. PUT заявките се използват, когато клиентът иска да 
актуализира съществуващ ресурс на сървъра. Често се използва за заместване или актуализиране
на ресурс с нови данни.

- **`@PutMapping`** е кратката версия на анотацията `@RequestMapping(method = RequestMethod.PUT)`. Тя е по-ясна и по-удобна за използване при работа с PUT заявки.

#### 2.4 Чрез `@DeleteMapping`

**`@DeleteMapping`** е специализирана анотация в Spring MVC, която се използва за 
обработка на **DELETE заявки** към конкретен URL път. DELETE заявките се използват, 
когато клиентът иска да премахне ресурс от сървъра, например изтриване на запис от база данни.

- **`@DeleteMapping`** е кратката версия на анотацията `@RequestMapping(method = RequestMethod.DELETE)`. 
Тя осигурява по-чиста и по-ясна декларация на методи, които обработват DELETE заявки.

#### 3. Работа с Model и ModelAndView в Spring MVC

#### 3.1 Model
`Model` е интерфейс, използван за предаване на данни от контролера към изгледа (view),
когато методът връща `String`, който представлява името на изгледа.

**Основни характеристики на `Model`**:
- Позволява добавяне на атрибути чрез `model.addAttribute(key, value)`.
- Данните в `Model` са достъпни в HTML шаблоните чрез `th:text`, `${}` и др.
- Често се използва с Thymeleaf, JSP и други View технологии.


#### 3.1 ModelAndView
ModelAndView е обект, който комбинира модела с изгледа. Използва се,
когато искаме едновременно да зададем името на изгледа и да предадем данни към него.

**Основни характеристики на `ModelAndView`**:
Позволява задаване на име на view чрез конструктора или метода setViewName().
Позволява добавяне на атрибути чрез addObject(key, value).
Използва се за по-структурирана и централизирана обработка на модел и изглед.

<a id="handler-method-type-annotaions"></a>
## IV. Типове и анотации използващи се в handler method-ите

### 1. Използване на `@PathVariable`

**`@PathVariable`** е анотация в Spring, която се използва за извличане на стойности
от пътищата (URLs) на заявките. Тя позволява да се съпоставят части
от пътя към параметри в методите на контролера.
---

#### Основна употреба:
Когато имате RESTful API, често използвате променливи в самия URL. С `@PathVariable`, 
Spring автоматично ще извлече стойността от пътя и ще я присвои на съответния параметър в метода.

>Примерен URL: `/hangman-games/17`  
>- Тук `17` може да бъде извлечено като `id` с помощта на `@PathVariable`.
---

### Правила и добри практики при използване на `@PathVariable`

1. **Имената трябва да съвпадат**:
    - Името на параметъра в метода на контролера трябва да съвпада с името на променливата, дефинирана в пътя.
    - Ако имената се различават, трябва изрично да посочите името в анотацията: `@PathVariable("id") Long productId`.
2. **Типизиране на параметъра**:
    - Уверете се, че типът на параметъра (например `Long`, `Integer`, `String`) съответства на очакваната стойност в URL.
3. **Задължителност**:
    - `@PathVariable` параметрите винаги се считат за задължителни. Ако не са налични в пътя, заявката няма да бъде съпоставена.
4. **Използване с множество променливи**:
    - Може да извличате няколко стойности от URL. Например `/api/users/{userId}/orders/{orderId}` може да съдържа два `@PathVariable` параметъра.
5. **Няма стойност по подразбиране**:
    - За разлика от `@RequestParam`, `@PathVariable` не поддържа стойности по подразбиране. Затова е важно винаги да се уверите, че стойностите се подават коректно.
6. **Не използвайте за query параметри**:
    - Използвайте `@PathVariable` само за променливи в пътя на URL. За query параметри (например `?limit=10`), използвайте `@RequestParam`.
---

> Примерен URL дизайн за RESTful API:
>- `/api/users/{id}`
>- `/api/users/{id}/hangman-games`

### 2. Използване на `@RequestParam` с параметри

**`@RequestParam`** е анотация в Spring, която се използва за извличане на стойности
от параметрите на URL заявката или от формуляри. Тя е полезна за обработка на параметри,
които се подават в URL като query parameters.

#### Задължителни параметри:

Ако параметърът е задължителен, може да зададете **`required = true`**. 
Ако параметърът не е подаден, Spring ще хвърли изключение и ще върне грешка със статус код 400.

#### Необходими параметри:

Ако параметърът не е задължителен, може да зададете **`required = false`** и да
обработите случая, когато той не бъде подаден. Това позволява да зададете логика
за работа със стойности по подразбиране или да върнете всички данни, когато параметърът липсва.

#### Стойности по подразбиране:

За да зададете стойност по подразбиране за параметър, използвайте **`defaultValue`**. 
Това ще се използва, когато параметърът не бъде подаден в заявката. По този начин може
да осигурите, че вашето приложение ще работи коректно дори без всички параметри.

#### Пример с URL параметри:

Ако имате URL като `/api/products?category=electronics&limit=20`, Spring ще извлече
стойностите за параметрите `category` и `limit` и ще ги предаде на метода в контролера.

#### Използване на `@RequestParam` с множества стойности:

**`@RequestParam`** може да обработва параметри, които съдържат множество стойности. 
Например, ако имате URL като `/api/products?category=electronics&category=clothing`, 
Spring ще обедини стойностите на параметрите в един списък. Това е полезно, когато се
подават параметри с една и съща променлива, например при филтриране на продукти по категории.
---

### Правила за използване на `@RequestParam`
1. **Ясно дефиниране на параметрите**:
    - Използвайте **`@RequestParam`** само за параметри, които са част от URL-а или са изпратени чрез HTTP форма. За тела на заявката използвайте **`@RequestBody`**.
2. **Стойности по подразбиране**:
    - За параметри, които не са задължителни, винаги задавайте стойност по подразбиране чрез **`defaultValue`**, за да избегнете грешки при липса на стойност.
3. **Валидиране на стойности**:
    - Използвайте Spring валидация, като например **`@Valid`** или **`@Validated`**, когато имате нужда да проверите дали стойностите на параметрите са валидни.
4. **Не използвайте `@RequestParam` за сложни типове**:
    - Ако имате сложни типове, като обекти с много полета, не използвайте **`@RequestParam`** за всеки параметър. В тези случаи използвайте **`@RequestBody`** за обработка на JSON данни.
---

### 3. Използване на `@RequestBody`

**`@RequestBody`** е анотация в Spring, която се използва за автоматично преобразуване на JSON,
XML или други формати от тялото на HTTP заявката към Java обекти. Когато клиентът 
(например фронтенд приложение или мобилно приложение) изпрати заявка с данни в тялото (body),
Spring използва `@RequestBody`, за да преобразува тези данни към обект в метода на контролера.
Обичайно се използва с POST, PUT или PATCH заявки, когато се изпраща цял обект или структура от данни.

#### ️ Правила и добри практики при използване на `@RequestBody`

1. **Трябва да имате подходящ DTO (Data Transfer Object)**:
    - Използвайте отделен Java клас, който описва структурата на очакваните данни. Полетата в класа трябва да съответстват на ключовете в JSON-а.
2. **Spring използва Jackson за конвертиране**:
    - По подразбиране, Spring Boot използва библиотеката Jackson, за да конвертира JSON към Java обект и обратно.
    - Уверете се, че имате `public` конструктор и `getters/setters`.
3. **Не се използва за query параметри**:
    - `@RequestBody` е само за данни, изпратени в тялото на заявката. Не използвайте за параметри от URL или query string – там използвайте `@PathVariable` и `@RequestParam`.
4. **Може да се използва с валидация**:
    - Комбинира се често с анотации като `@Valid` или `@Validated`, за да се валидират входните данни.
    - При грешка, Spring може автоматично да върне статус код 400 и описание на грешките.
5. **Една заявка – един `@RequestBody`**:
    - В един метод на контролер може да има само един параметър с `@RequestBody`. За останалите данни използвайте други анотации.
6. **Типът на параметъра трябва да съвпада с изпратения JSON**:
    - Ако се очаква обект, JSON-ът трябва да е обект. Ако се очаква списък – трябва да е JSON масив. Несъответствие ще доведе до грешка.

>Примери за заявки, които използват `@RequestBody`:
>- POST `/api/products` с JSON тяло, съдържащо данни за нов продукт.
>- PUT `/api/users/{id}` с JSON тяло, актуализиращо информацията за потребител.

### 4. Използване на `ResponseEntity<T>`

**`ResponseEntity<T>`** е клас от Spring, който представлява пълния HTTP отговор, включващ:

- тялото на отговора (response body),
- HTTP статус код (напр. 200 OK, 201 CREATED, 404 NOT FOUND),
- HTTP хедъри.

Използва се, когато искаме по-голям контрол върху това какъв отговор изпраща сървърът към клиента.

#### Предимства на `ResponseEntity<T>`

1. **Контрол върху HTTP статус кода**:
    - Позволява ви да зададете специфичен статус код (например `HttpStatus.CREATED` при успешно създаване на ресурс).
    - Улеснява изпращането на грешки или специфични отговори, напр. 400 Bad Request, 404 Not Found и т.н.
2. **Добавяне на HTTP хедъри**:
    - Може да добавите допълнителни заглавки (headers), като `Location`, `Authorization`,`Content-Type` и др.
3. **Поддръжка на типизирани отговори**:
    - `ResponseEntity<T>` позволява връщането на произволен обект (`T`) в отговора, включително списъци, DTO обекти или дори низове.

#### Обичайни сценарии за използване на `ResponseEntity<T>`

- **Успешно създаване на ресурс (201 Created)**:
  Изпраща се създаденият обект и статус код 201, евентуално и Location header.

- **Празен отговор със статус (204 No Content)**:
  Полезно при успешни операции, които не връщат съдържание (напр. DELETE).

- **Грешки или невалидни заявки**:
  При връщане на статуси като 400 (Bad Request), 404 (Not Found), 403 (Forbidden) и т.н.
---

#### Добри практики при използване на `ResponseEntity<T>`

- Използвайте `ResponseEntity.ok(obj)` за стандартни 200 OK отговори.
- Използвайте `ResponseEntity.status(HttpStatus.CREATED).body(obj)` при създаване на нов ресурс.
- Използвайте `ResponseEntity.notFound().build()` при липса на резултат.
- Използвайте `ResponseEntity.badRequest().body(errorMessage)` за грешки от страна на клиента.
- Може да комбинирате с `Optional<T>`, за да връщате 404, когато резултатът липсва.
---

#### Допълнителни възможности

- **Изграждане на отговор с ResponseEntityBuilder**:
  Можете да използвате `.status()`, `.headers()`, `.body()` и `.build()`, за да изградите отговора поетапно.

- **Използване с `@RestController`**:
  Въпреки че Spring автоматично сериализира обекти към JSON, използването на `ResponseEntity` дава по-голяма гъвкавост и яснота.
---

### 5. Използване на `@ResponseBody`

**`@ResponseBody`** е анотация в Spring, която указва, че резултатът от даден метод 
трябва да бъде директно записан в HTTP отговора (response body), вместо да се интерпретира
като име на изглед (view name).

- Казва на Spring да сериализира връщания обект (обикновено към JSON или XML) и да го изпрати директно в тялото на HTTP отговора.
- Най-често използван формат е JSON, особено при REST API.

#### Кога се използва `@ResponseBody`

- При създаване на RESTful уеб услуги.
- Когато не се използва традиционен HTML изглед (напр. JSP, Thymeleaf).
- Когато трябва да върнем данни към front-end приложение (например React, Angular, мобилно приложение и др.).

#### Връзка с `@RestController`

- Анотацията `@RestController` е съкратен запис за `@Controller + @ResponseBody` – всички методи автоматично връщат съдържание в response body.
- Ако използвате само `@Controller`, тогава трябва да добавяте `@ResponseBody` към всеки метод, който трябва да връща данни, а не изглед.

#### Добри практики при използване на `@ResponseBody`

- Използвайте с DTO класове (Data Transfer Objects), когато връщате структурирани данни.
- Избягвайте връщане на Entity класове директно, освен ако не контролирате изцяло съдържанието.
- Използвайте с библиотеки като Jackson (по подразбиране в Spring Boot), която автоматично сериализира Java обекти към JSON.

<a id="dependency-injection"></a>

<a id="validation-request-body"></a>
## VI. Начини за валидиране на HTTP request body

Spring предоставя мощна интеграция с Java Bean Validation API чрез анотацията `@Valid`.
Използва се за автоматична валидация на данни, подавани от клиент, обикновено в тялото на заявката.

- Валидацията в Spring е механизъм, който позволява автоматично проверяване на входните данни – например
  дали потребител е попълнил всички задължителни полета, дали е въведен валиден имейл,
  дали числова стойност попада в определен диапазон и т.н.

- Това се постига чрез използването на специални анотации, които се добавят
  към полетата в Java класове (често наричани DTO – Data Transfer Object).
  Тези анотации описват какви правила трябва да бъдат спазени. Например може да се укаже,
  че дадено поле не трябва да е празно, че имейлът трябва да е в правилен формат,
  или че възрастта трябва да е поне 18 години.

- Когато Spring получи заявка (например POST с JSON тяло), той автоматично валидира данните,
  ако е използвана анотацията @Valid върху параметъра. Ако някое от правилата не е спазено,
  Spring спира изпълнението на метода и връща грешка (обикновено с код 400 Bad Request),
  заедно с описание на всяка конкретна грешка – коя стойност липсва или е невалидна.

### 1. Какво е `@Valid`?
- Анотация от Java стандартната библиотека (JSR-303/JSR-380), която се използва, за да валидира обекти по зададени правила.
- Често използвана в Spring заедно с `@RequestBody`, `@ModelAttribute` или дори `@PathVariable`/`@RequestParam` (в някои специфични случаи).
- Позволява проверка на входни данни автоматично, преди да се изпълни логиката в контролера.

### 2. Необходима зависимост

```xml
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-validation</artifactId>
</dependency>
```

### 3. Анотации за валидация с @Valid

| Анотация                   | Приложима за типове                  | Описание                                                    |
|----------------------------|--------------------------------------|-------------------------------------------------------------|
| `@NotNull`                | Всички обекти                        | Не позволява `null` стойност                                |
| `@NotBlank`               | `String`                             | Не позволява празен или само whitespace текст               |
| `@NotEmpty`               | `String`, `List`, `Set`, `Map`       | Не позволява празна стойност (но може да е `null`)         |
| `@Size(min, max)`         | `String`, колекции, масиви           | Определя минимален и максимален размер                      |
| `@Email`                  | `String`                             | Валидиран имейл адрес                                       |
| `@Pattern`                | `String`                             | Съвпадение с регулярен израз                                |
| `@Min(value)`             | `int`, `long`, `double`              | Минимална допустима стойност                                |
| `@Max(value)`             | `int`, `long`, `double`              | Максимална допустима стойност                               |


<a id="configuration"></a>

<a id="thymeleaf"></a>
## V. Генериране на потребителски интерфейс & Thymeleaf

В уеб приложенията, потребителският интерфейс е изграден чрез **View Technologies**, 
които позволяват визуализиране на данни. Един от най-популярните шаблонни двигатели
за **Spring MVC** приложения е **Thymeleaf**. Thymeleaf е лесен за интегриране
и осигурява чист, удобен начин за работа със HTML и други шаблони в Spring.

### 1. За Thymeleaf
Thymeleaf е шаблонен двигател, използван в Spring MVC, който позволява генерирането
на динамични HTML страници. Той е напълно съвместим със стандартните HTML
файлове и осигурява възможността за създаване на динамични шаблони с
добавяне на **JSP-like** функционалности в HTML.

### 2. Основни характеристики на Thymeleaf

- **Лесен за използване** – използва стандартни HTML шаблони, което го прави удобен за разработчици и дизайнери.
- **Поддържа Spring интеграция** – Thymeleaf работи отлично с Spring MVC и може да бъде конфигуриран като основен шаблонен двигател.
- **Поддържа различни шаблони** – Thymeleaf може да генерира не само HTML, но и XML, текстови и други формати.
- **Лесен за дебъгване** – използва синтаксис, който е лесен за разбиране и поддържа вградени функции за логване на грешки.

### 3. Видове тагове в Thymeleaf

Thymeleaf използва различни видове тагове, които се добавят към
стандартния HTML синтаксис за динамично генериране на съдържание.

### 3.1 Необходима зависимост
```xml
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-thymeleaf</artifactId>
</dependency>
```

### 3.2 **Тагове за обработка на атрибути**
- **`th:text`** – Използва се за динамично добавяне на текст в HTML елементи.
```html
<p th:text="${message}">Текст по подразбиране</p>
```

- **`th:if`** – Условен таг, който рендира HTML елемента само ако условието е вярно.
```html
<div th:if="${user != null}">Добре дошъл, <span th:text="${user.name}"></span></div>
```

- **`th:each`** – За циклично преминаване през списъци или масиви
и динамично рендиране на HTML елементи.
```html
<ul>
  <li th:each="product : ${products}" th:text="${product.name}">Product Name</li>
</ul>
```

- **`th:action`** – Задава динамичен URL адрес за действие на формата.
```html
<form th:action="@{/submitForm}" method="post">
  <input type="text" th:field="*{name}" />
  <button type="submit">Submit</button>
</form>
```

### 3.3 Допълнителни ресурси
- [Официална документация на Thymeleaf](https://www.thymeleaf.org/)

<a id="rest-apis"></a>
## VII. Какво е API ?

### 1.Web Services
Уеб услугите са начин компютърни приложения да комуникират помежду си през интернет
(или локална мрежа), използвайки стандартизирани технологии и протоколи.
Те предоставят функционалност (например: регистрация на потребител, търсене на продукти,
извличане на данни) на други системи, независимо на какъв език или платформа са изградени.

#### Основни характеристики на уеб услугите:
- Работят чрез интернет протоколи (най-често HTTP).
- Платформено и езиково независими (напр. Java приложение може да използва услуга, написана на Python).
- Използват стандарти като XML, JSON, SOAP или REST.
- Предоставят машина към машина (machine-to-machine) комуникация.
- имат активна и слушаща страна
- stateless

#### Как изглежда една уеб услуга?
  - URL (крайна точка / endpoint) – например: https://api.example.com/products
  - Входни параметри – изпратени чрез URL или в тялото на заявка
  - Резултат – често върнат в JSON или XML формат

#### Основни видове уеб услуги:

**1. SOAP (Simple Object Access Protocol)**:
- Използват XML.
- Имат строг формат.
- Изискват описание чрез WSDL (Web Services Description Language).
- По-тежки, но с висока сигурност и стандартизация.
- Подходящи за корпоративни системи.

**2. RESTful Web Services**:
- Използват HTTP и стандарти като JSON и URI.
- Леки, лесни за използване и широкоразпространени.
- Много подходящи за уеб и мобилни приложения.

**3. WebSockets**:
- Не са типични "уеб услуги", но позволяват двупосочна комуникация в реално време между клиент и сървър.
- Използват се при чатове, live обновяване на данни, игри.
- Базирани на стандартен TCP сокет, отворен през HTTP.

### 2. API

API означава Application Programming Interface – интерфейс за програмиране на приложения.
Това е набор от правила, протоколи и инструменти, който позволява на две
различни софтуерни системи да комуникират помежду си.

Просто казано: API е договор за комуникация между клиент (например уеб приложение,
мобилно приложение или друга система) и сървър (бекенд), който определя:
- какви заявки могат да се изпращат;	
- в какъв формат трябва да са те (например JSON);	
- какво ще върне сървърът като отговор;	
- какви действия могат да се извършват.

### 3. REST API и RESTful архитектура

#### Какво са REST API-та и какво ги прави RESTful?

- **REST** (Representational State Transfer) е архитектурен стил, използван за изграждане на уеб услуги, който дефинира как клиентите и сървърите трябва да комуникират чрез HTTP протокола. **REST API** (Application Programming Interface) е интерфейс, който използва принципите на REST за предоставяне на достъп до ресурси в уеб приложения. Основната идея на REST е да предоставя лесен, стандартизиран и ефективен начин за обмен на данни между клиент и сървър.

- **RESTful** означава, че API-то спазва основните принципи и ограничения на REST архитектурния стил. Това включва използването на HTTP методи (GET, POST, PUT, DELETE и др.), както и добре дефинирани URL ресурси и статут кодове за отговор.
---

#### Основни принципи на REST

#### 1. Клиент-сървър архитектура
- Клиентът и сървърът са разделени, като клиентът изпраща заявки към сървъра, който обработва тези заявки и връща отговори.
- Това разделение позволява лесно мащабиране и независимост между двата компонента.

#### 2. Без състояние (Stateless)
- Всеки HTTP заявка трябва да съдържа цялата информация, необходима за нейното обработване. Сървърът не запазва информация за състоянието на клиента между различните заявки.
- Това означава, че всяка заявка е независима и трябва да съдържа всичко необходимо, за да бъде обработена.

#### 3. Кешируемост (Cacheable)
- Ресурсите, изпратени от сървъра, трябва да съдържат указания дали могат да бъдат кеширани от клиента, като по този начин се намалява броят на заявките към сървъра и увеличава ефективността на приложението.

#### 4. Еднозначност на интерфейса (Uniform Interface)
- API-то трябва да има еднозначен и стандартизиран интерфейс, което улеснява взаимодействието с него.
- Това означава, че ресурсите трябва да бъдат достъпни чрез добре дефинирани URL адреси и да следват еднакви принципи при обработка на заявки и отговори.

#### 5. Система от ресурси (Resources)
- Ресурсите в REST са идентифицирани чрез URL адреси. Всеки ресурс (например потребители, продукти и т.н.) трябва да има уникален идентификатор.
- Чрез HTTP методите (GET, POST, PUT, DELETE и т.н.) се извършват различни операции върху ресурсите.

#### 6. Слоеност (Layered System)
- Архитектурата може да бъде изградена от няколко слоя, като всеки слой има различна отговорност. Клиентът комуникира със сървърния слой, без да знае за междинните слоеве, като например проксита и балансировки на натоварването.
---

#### Добри и лоши практики при изграждането на REST API

#### Добри практики:
1. **Използване на HTTP методите според тяхното значение:**
    - `GET` за извличане на данни.
    - `POST` за създаване на нови ресурси.
    - `PUT` за актуализиране на ресурси.
    - `DELETE` за изтриване на ресурси.

2. **Поддържане на консистентност в URL адресите:**
    - Използвайте ясни и описателни URL адреси.
    - Например, `/users` за списък с потребители, `/users/{id}` за конкретен потребител.

3. **Използване на подходящи статус кодове:**
    - `200 OK` за успешни операции.
    - `201 Created` при създаване на ресурс.
    - `400 Bad Request` при невалидна заявка.
    - `404 Not Found` когато ресурсът не е намерен.

4. **Обработка на грешки:**
    - Включвайте детайлни съобщения за грешки в отговорите.
    - Пример: `{ "error": "User not found", "message": "No user exists with id 123" }`.

5. **Използване на версии в API-то:**
    - Използвайте версиониране на API-то, за да може да се правят промени без да се нарушава съществуваща функционалност.
    - Например: `/api/v1/users`, `/api/v2/users`.

6. **Използване на JSON или XML за данни:**
    - JSON е най-популярният формат за данни в REST API.
    - Уверете се, че API-то обработва и изпраща данни в правилния формат.
---

#### Лоши практики:
1. **Неясни и объркващи URL адреси:**
    - Избягвайте URL адреси, които не описват ясно какви ресурси се достъпват.
    - Например: `/getUserData`, `/api/executeAction`.

2. **Използване на HTTP методите неправилно:**
    - Например, използване на `POST` за извличане на данни, когато трябва да се използва `GET`.

3. **Липса на обработка на грешки:**
    - API-та без ясни съобщения за грешки са трудни за дебъгване и използване.
    - Не оставяйте клиентите да гадаят какво е станало с техните заявки.

4. **Промени в API-то без версия:**
    - Няма да може да поддържате обратно съвместимост, ако промените API-то без версия.
    - Версионирането на API е критично за управлението на дългосрочни проекти.

5. **Липса на документация:**
    - Без подробна документация, използването на API-то става трудно за други разработчици.
    - Включете примери за заявки и отговори, както и описание на параметрите.
---


<a id="resources"></a> 
## VIII. Допълнителни материали

- [Създаване на handler методи](https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-controller/ann-methods.html)
- [Мапване на HTTP URL и HTTP Method към java метод](https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-controller/ann-requestmapping.html)
- [Изграждане на REST API с Spring, конфигурация на HTTP метод](https://www.baeldung.com/rest-with-spring-series)
